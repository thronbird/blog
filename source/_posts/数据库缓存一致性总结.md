---
title: 数据库|缓存一致性总结
---

### 数据库主从不一致解决方案：

**方案一：忽略**--如果业务能够接受，别把系统架构搞得太复杂

**方案二：强制读主**--使用一个高可用主库提供数据库服务--过于粗暴

**方案三：选择性读主**--写主库时将哪个库，哪个表，哪个主键三个信息拼装一个key设置到cache里，这条记录的超时时间，设置为“主从同步时延（比如1s）”,然后读的时候先判断cache有没有，有则读主库，否则读从库

ref:[数据库主从不一致，怎么解？](<https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961330&idx=1&sn=4bdbada3b26d4fc2fc505f7a0f2ad7c4&chksm=bd2d022e8a5a8b38e59f0dfffba7ca407fe8711644b3794832572dd822c665205bb820cdddf7&scene=21>)

### 数据库|缓存一致性解决方案：

Cache Aside Pattern:

**查询**：cache-》如果没有则查询数据库 -》放回cache 

**更新**：更新数据库-》删除缓存
(其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。像 mybatis，hibernate，都有懒加载思想)

1.防止读写并发导致数据库和缓存不一致的情况（线程1更新db为x-》线程2更新db为y-》线程2更新缓存为y-线程1更新缓存为y===》db和缓存不一致）

2.在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值的。

PS:特殊情况下：读写并发则不可行（线程1读缓存（miss）=》线程1读数据库=>线程2写数据库=》线程2使缓存失效=》线程1放入老数据库的数据） 不过概率极低，写db比读要慢

**但如果删除缓存失败就会导致数据库和缓存不一致了==>(<http://www.jintiankansha.me/t/jmm4fB2a8S>)
(<http://www.jintiankansha.me/t/0bKZVSdist>)**

- 延时双删(删缓存|删数据库|睡眠|再删) 
- 订阅mysql binlog更新缓存数据
- 更新请求放入JVM队列排序 读请求循环判断是否已经更新

